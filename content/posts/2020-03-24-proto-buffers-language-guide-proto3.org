#+TITLE: 프로토 버퍼 언어 안내(proto3) 번역본
#+SUBTITLE: proto buffers language guide(proto3)
#+AUTHOR: yeongcheon
#+DATE: 2020-03-24 22:00:00 +0900
#+TAGS[]: protobuffers proto3 google
#+DRAFT: true

매번 [[https://developers.google.com/protocol-buffers/docs/proto3#simple][영어문서]] 보기 빡쳐서 직접 번역기 돌려가며 쓰는 번역본. 영어를 잘 못하기 때문에 오역이 있을 수(+분명히+) 있습니다.

* Language Guide(proto3)
** Defining A Message Type
   우선 매우 간단한 예제를 살펴보겠습니다.. 검색 요청을 위한 메세지 타입을 정의하고자 하는데 이 메세지는 쿼리 문자열^(역자 주: query), 요청 페이지^(역자 주: page_number), 그리고 페이지당 결과 갯수^(역자 주: result_per_page)를 가지고 있습니다. 

   #+BEGIN_SRC proto
   syntax = "proto3";
   
   message SearchRequest {
     string query = 1;
     int32 page_number = 2;
     int32 result_per_page = 3;
   }

   #+END_SRC

   + 첫 번째 줄은 이 파일이 *proto3* 문법을 사용하고 있음을 나타냅니다. 만약 이 구문이 없으면 컴파일러는 이 파일이 [[https://developers.google.com/protocol-buffers/docs/proto][proto2]] 문법을 사용하고 있다고 인식합니다. 이 구문은 무조건 파일의 제일 첫 번째 줄에 와야하며 앞에 공백이나 주석조차 허용하지 않습니다.
   + ~SearchRequest~ 메세지는 세 가지 필드를 정의하고 있습니다(이름/값 쌍), 각 필드는 이름과 타입으로 이루어져 있습니다.
*** Specifying Field Types
	위 예제에서 모든 필드는 [[https://developers.google.com/protocol-buffers/docs/proto3#scalar][스칼라 타입]]입니다(int32 타입 2개, string 타입 1개). 그렇지만 [[https://developers.google.com/protocol-buffers/docs/proto3#enum][열거형]]이나 다른 메세지를 타입으로 지정할 수 있습니다.
*** Assigning Field Numbers
	위에서 봤듯이, 각 필드는 저마다 *고유한 번호*를 가지고 있습니다. 이 필드 번호들은 메세지를 [[https://developers.google.com/protocol-buffers/docs/encoding][바이너리 포맷]]으로 변환할 때 사용되므로 한번 정의한 이 후 절대로 바꿔서는 안됩니다. 인코딩 시 필드 번호는 1-15 범위까지는 1 바이트, 16에서 2047 범위까지는 2 바이트를 사용합니다(자세한 내용은 [[https://developers.google.com/protocol-buffers/docs/encoding#structure][proto Buffer Encoding]]에서 확인). 그러므로 자주 발생하는 메세지 요소들은 1-15 범위에 할당하는게 좋습니다. 나중에 빈번하게 접근할 요소가 추가될 수 있으므로 미리 여유 공간을 확보해 놓으세요.

	지정할 수 있는 가장 작은 필드 번호는 1, 가장 큰 필드 번호는 2^29 - 1 또는 536870911 입니다. 그리고 19000-19999 범위의 필드 번호는 프로토콜 버퍼 구현을 위해 미리 예약되어 있으므로 사용할 수 없습니다. 만약 당신의 ~.proto~ 파일에서 예약된 필드 번호 중 하나를 사용하면 프로토콜 버퍼 컴파일러는 에러를 반환할 것입니다. 이와 마찬가지로, 이전에 [[https://developers.google.com/protocol-buffers/docs/proto3#reserved][예약된]] 필드 번호도 사용할 수 없습니다.
*** Specifying Field Rules
	메세지 필드는 다음 중 하나일 수 있습니다,

	+ 단일 필드: 잘 디자인 된 메세지는 0개 또는 하나의 단일 필드 형식을 갖습니다(하나 이하). 그리고 단일 필드는 프로토 버퍼3 문법에서 기본 필드입니다.
	+ 반복 필드: 이 필드는 0을 포함해서 여러번 반복될 수 있습니다. 반복되는 값은 순서는 유지됩니다.

	~proto3~ 에서, 스칼라 숫자 타입 ~반복~ 필드는 기본적으로 ~압축(packed)~ 인코딩을 사용합니다.

	~압축~ 인코딩에 대해서는 [[https://developers.google.com/protocol-buffers/docs/encoding#packed][Protocol Buffer Encoding]] 에서 자세히 알아볼 수 있습니다.
*** Adding More Message Types
	여러개의 메세지 타입을 하나의 ~.proto~ 파일 안에 정의할 수 있습니다. 만약 당신이 다수의 서로 연관된 메세지를 정의할 때 매우 유용할 것입니다. 예를 들어, ~SearchResponse~ 메세지를 응답 형식으로 작성하고 싶다면 같은 ~.proto~ 파일에 추가할 수 있습니다.
	#+BEGIN_SRC proto
	message SearchRequest {
      string query = 1;
      int32 page_number = 2;
      int32 result_per_page = 3;
	}
   
	Message Searchresponse {
      ...
	}

	#+END_SRC
*** Adding Comments
	C/C++ 처럼 ~//~ 또는 ~/* ... */~ 스타일의 주석 문법을 ~.proto~ 파일에서 사용할 수 있습니다.
	#+BEGIN_SRC proto
	/* SearchRequest represents a search query, with pagination options to
     * indicate which results to include in the response. */

	message SearchRequest {
      string query = 1;
      int32 page_number = 2;  // Which page number do we want?
      int32 result_per_page = 3;  // Number of results to return per page.
	}

	#+END_SRC
*** Reserved Fields
	필드를 완전히 삭제 또는 주석 처리하여 메세지를 업데이트 하면 향후 사용자가 메세지를 업데이트 할 때  필드 번호를 재사용 할 수 있습니다. 이는 만약 이전 버전의 ~.proto~ 파일을 사용할 때 데이터 손상이나 개인정보 문제 등등 심각한 문제가 발생할 수 있습니다. 삭제된 필드의 필드 번호(또는 json 직렬화 문제를 일으킬 수 있는 이름)를 예약하도록 지정하면 이러한 문제가 발생하는 것을 피할 수 있습니다. 만약 향후 사용자가 예약된 필드 식별자^(역자 주: 필드 번호 또는 이름)를 사용하려고 할 경우 프로토콜 버퍼 컴파일러가 경고를 해 줄 것입니다.
	#+BEGIN_SRC proto
	message Foo {
      reserved 2, 15, 9 to 11;
      reserved "foo", "bar";
	}
	#+END_SRC
	동일한 ~예약~ 구문에서는 필드 이름과 이름 번호를 혼용할 수 없습니다.
*** What's Generated From Your *.proto*?
	~.porto~ 파일을 프로토 버퍼 컴파일러를 이용해 컴파일 하면 컴파일러는 당신이 선택한 언어로 코드를 생성합니다. 당신은 해당 메세지 타입에 해당하는 필드값 입출력, 메세지 출력 스트림에 대한 직렬화 작업, 그리고 입력 스트림에 대한 파싱 작업을 수행해야 합니다.

	+ *C++* 언어의 경우, 컴파일러는 ~.proto~ 파일마다 각 메세지별로 클래스 파일, ~.h~ , 그리고 ~.cc~ 파일을 생성합니다.
	+ *Python* 언어는 조금 다릅니다. 파이썬 컴파일러는 ~.proto~ 파일에 일는 메세지마다 정적 디스크립터 모듈을 생성한 후 메타 클래스와 런타임에 필요한 데이터 접근 클래스를 생성하는 데 사용합니다.
	+ *Go * 언어의 경우, 컴파일러는 파일 안의 각 메세지마다 ~.pb.go~ 파일을 생성합니다.
	+ *Ruby* 언어의 경우, 컴파일러는 메세지 타입마다 *.rb* 파일을 생성합니다.
	+ *Objective-C* 언어의 경우, 컴파일러는 파일에 설명 된 각 메시지 유형에 대한 클래스와 함께 각 ~.proto~ 에서 ~pbobjc.h~ 및 ~pbobjc.m~ 파일을 생성합니다.
	+ *C#* 언어의 경우, 컴파일러는 각 ~.proto~ 파일에 설명 된 각 메시지 유형에 대한 클래스와 함께 ~.cs~ 파일을 생성합니다.
	+ *Dart* 언어의 경우, 컴파일러는 파일의 각 메시지 유형에 대한 클래스와 함께 ~.pb.dart~ 파일을 생성합니다.
	다른 언어에 대한 튜토리얼을 통해 API 사용법을 좀 더 자세히 알아볼 수 있습니다(proto3 버전은 출시 예정). 더 자세한 [[https://developers.google.com/protocol-buffers/docs/reference/overview][API 사용법]]은 관련 API를 참조(proto3 버전은 출시 예정).
** Scalar Value Types
   스칼라 메세지 필드는 다음 유형 중 하나를 가질 수 있습니다. 아래의 표는 ~.proto~ 파일에 지정된 유형과 그에 상응하는 자동 생성된 클래스의 타입을 보여줍니다.
| .proto type | Notes                                                                                                                       | C++ Type | Java Type  | Python Type | Go Type | Ruby Type                      | C# Type    | PHP            | Dart Type |
|-------------+-----------------------------------------------------------------------------------------------------------------------------+----------+------------+-------------+---------+--------------------------------+------------+----------------+-----------|
| double      |                                                                                                                             | double   | double     | float       | float64 | Float                          | double     | float          | double    |
| float       |                                                                                                                             | float    | float      | float       | float32 | Float                          | float      | float          | double    |
| int32       | 가변 길이 인코딩을 사용합니다. 음수를 인코딩 하는 데 비효율적입니다. 필드에 음수가 있는 경우 sint32를 사용하는 게 좋습니다. | int32    | int        | int         | int32   | Fiexnum or Bignum(as required) | int        | integer        | int       |
| int64       | 가변 길이 인코딩을 사용합니다. 음수를 인코딩 하는 데 비효율적입니다. 필드에 음수가 있는 경우 sint64를 사용하는 게 좋습니다. | int64    | long       | int/long    | int64   | Bignum                         | long       | integer/string | Int64     |
| unit32      | 가변 길이 인코딩을 사용합니다.                                                                                              | unit32   | int        | int/long    | uint32  | Fixnum or Bignum(as required)  | uint       | integer        | int       |
| unit64      | 가변 길이 인코딩을 사용합니다.                                                                                              | unit64   | long       | int/long    | uint64  | Bignum                         | ulong      | integer/string | Int64     |
| sint32      | 가변 길이 인코딩을 사용합니다. 부호있는 int 값. 일반 int32보다 음수를 더 효율적으로 인코딩합니다.                           | int32    | int        | int         | int32   | Fixnum or Bignum(as required)  | int        | integer        | int       |
| sint64      | 가변 길이 인코딩을 사용합니다. 부호있는 int 값. 일반 int64보다 음수를 더 효율적으로 인코딩합니다.                           | int64    | long       | int/long    | int64   | Bignm                          | long       | integer/string | Int64     |
| fixed32     | 항상 4 바이트 크기를 갖습니다. 2^28 이상의 값을 사용할 경우 uint32보다 효율적입니다.                                         | uint32   | int        | int/long    | uint32  | Fixnum or Bignum(as required)  | uint       | integer        | int       |
| fixed64     | 항상 8 바이트 크기를 갖습니다. 2^28 이상의 값을 사용할 경우 uint64보다 효율적입니다.                                         | unit64   | long       | int/long    | uint64  | Bignum                         | ulong      | integer/string | Int64     |
| sfixed32    | 항상 4 바이트 크기를 갖습니다.                                                                                              | int32    | int        | int         | int32   | Fixnum or Bignum(as required)  | int        | integer        | int       |
| sfixed64    | 항상 8 바이트 크기를 갖습니다.                                                                                              | int64    | long       | int/long    | int64   | Bignum                         | long       | integer/string | int64     |
| bool        |                                                                                                                             | bool     | boolean    | bool        | bool    | TrueClsas/FalseClass           | bool       | boolean        | bool      |
| string      | 문자열 타입은 항상 UTF-8 또는 7비트 아스키 텍스트로 구성되어야 하며, 2^32 길이보다 길 수 없습니다.                           | string   | String     | str/unicode | string  | String(UTF-8)                  | string     | string         | String    |
| bytes       | 2^32 길이 이하의 임이의 바이트 시퀀스를 포함 할 수 있습니다.                                                                                                                | string   | ByteString | str         | []byte  | String(ASCII-8BIT)             | ByteString | string         | List<int> |
   [[https://developers.google.com/protocol-buffers/docs/encoding][프로토콜 버퍼 인코딩]]에서 메세지를 직렬화 할 때 이러한 타입딀 인코딩 되는 방법에 대해 자세히 알아볼 수 있습니다.
** Default Values
   메세지를 파싱할 때 인코딩 된 메세지에 특정 특이 요소가 포함되어 있지 않으면 파싱된 객체의 해당 필드가 해당 필드의 기본값으로 설정됩니다. 이 기본값은 유형별로 다릅니다.

   + String 타입의 경우, 기본값은 빈 문자열 값입니다.
   + bytes 타입의 경우, 기본값은 빈 bytes 값입니다.
   + bools 타입의 경우, 기본값은 false 입니다.
   + 숫자 타입의 경우, 기본값은 0 입니다.
   + [[https://developers.google.com/protocol-buffers/docs/proto3#enum][enums]] 타입의 경우, 기본값은 가장 처음 정의된 enum 값이며 0이어야 합니다.
   + 메세지 필드의 경우, 필드 값은 셋팅되지 않습니다. 정확한 값은 종속된 언에 따라 다릅니다. 자세한 내용은 [[https://developers.google.com/protocol-buffers/docs/reference/overview][코드 생성 가이드]]를 참고하세요.
   반복 필드 타입의 기본값은 빈 값입니다(일반적으로 프로그래밍 언어에선 빈 list 타입을 갖습니다).

   스칼라 메세지 필드의 경우, 한번 메세지가 파싱되면 필드가 기본값(ex: boolean 필드가 false로 설정)이 명시적으로 설정었는지 또는 설정되지 않았는지 알 방법이 없습니다. 메세지 타입을 정의 할 때 주의하세요. 예들 들어, 만약 당신이 이런 동작을 원치 않는다면 일부 필드값을 ~false~ 로 설정하는 작업은 하지 마세요^(역자 주: 번역이 잘 된건지 모르겠네요..). 또한 스칼라 타입 메세지 필드가 기본값 설정된 경우, 그 값은 직렬화 되지 않습니다.

   [[https://developers.google.com/protocol-buffers/docs/reference/overview][코드 생성 가이드]]에서 당신이 사용하는 언어에 대해서 기본적으로 어떻게 코드를 생성하는지 자세히 알아보세요.
** Enumerations
   메세지를 선언할 때, 미리 정의된 값들이 필요한 경우가 있습니다. 예를 들어, 당신이 각 ~SearchRequest~ 마다 ~corpus~ 필드를 추가하고 싶다고 가정해봅시다. corpus 필드는 ~UNIVERSAL~, ~WEB~, ~IMAGES~, ~LOCAL~, ~NEWS~, ~PRODUCTS~, ~VIDEO~ 값 중 하나를 가질 수 있습니다. 당신의 메세지 타입에 간단하게 열거형^(역자 주: enum) 상수값을 추가할 수 있습니다.

   #+BEGIN_SRC proto
   message SearchRequest {
     string query = 1;
     int32 page_number = 2;
     int32 result_per_page = 3;
     enum Corpus {
       UNIVERSAL = 0;
       WEB = 1;
       IMAGES = 2;
       LOCAL = 3;
       NEWS = 4;
       PRODUCTS = 5;
       VIDEO = 6;
     }
     Corpus corpus = 4;
   }
   #+END_SRC
   위 예제에서 보시다시피, ~Corpus~ enum의 첫번재 상수값은 0이어야 합니다. 모든 enum은 *무조건* 첫번째 상수값으로 0을 가지고 있어야 합니다. 그 이유는 아래와 같습니다.
   + 0이어야 하는 이유는 0이 숫자 타입의 [[https://developers.google.com/protocol-buffers/docs/proto3#default][기본값]]이기 때문입니다.
   + 0이 첫번째 요소에 있어야 하는 이유는 [[https://developers.google.com/protocol-buffers/docs/proto][proto2]] 문법과 호환을 위해서인데, proto2에선 항상 enum의 첫번째 요소가 기본값입니다.
   동일한 enum 값에 서로 다른 별칭을 지정할 수 있습니다. 이를 위해서는 ~allow_alias~ 옵션이 ~true~ 이어야 합니다. ~true~ 로 지정하지 않고 별칭을 사용한다면 컴파일러는 에러를 발생할 것입니다.
   #+BEGIN_SRC proto
   enum EnumAllowingAlias {
     option allow_alias = true;
     UNKNOWN = 0;
     STARTED = 1;
     RUNNING = 1;
   }
   enum EnumNotAllowingAlias {
     UNKNOWN = 0;
     STARTED = 1;
     // RUNNING = 1;  // Uncommenting this line will cause a compile error inside Google and a warning message outside.
   }
   #+END_SRC
   열거형 상수값의 범위는 32bit integer 까지입니다. ~enum~ 값으로 [[https://developers.google.com/protocol-buffers/docs/encoding][가변형 인코딩]] 또는 음수값을 사용할 경우 비효율적이므로 추전하지 않습니다. 이전 예제에서 보았듯이 당신은 ~enum~ 을 메세지와 함께 정의할 수 있고 또한 ~enum~ 은 당신의 ~.proto~ 파일 내부의 다른 메세지에도 재사용 할 수 있습니다. 또한 ~enum~ 은 한 메세지 안에서 정의하고 다른 다른 메세지에서도 사용할 수 있습니다. 다음의 문법을 사용해서요. ~MessageType.EnumType~

   ~enum~ 이 포함된 ~.proto~ 파일을 프로토콜 버퍼 컴파일러로 실행할 때, 생성된 코드는 Java, C++에 해당하는 enum을 가지며, 파이썬의 경우에는 런타임 시 사용되는 정수 상수값으로 이루어진 ~EnumDescriptor~ 클래스가 생성됩니다.

   역직렬화 할 때는, 인식할 수 없는 enum 값은 언어마다 표현방식이 다르긴 하지만 일단은 메세지 안에 보존됩니다. C++이나 Go처럼 지정된 enum값을 벗어난 개방형 enum을 지원하는 언어의 경우, 알 수 없는 enum 값은 기본 정수값으로 저장됩니다. Java와 같이 비개방 enum의 경우, 인식되지 않은 값을 사용하여 표현하며 기본 정수는 특수 접근자를 이용해 접근할 수 있습니다. 두 경우 모두 메세지가 직렬화 될 때 인식할 수 없는 값이 메세지와 함께 직렬화 된다.

   ~enum~ 타입이 당신의 어플리케이션에서 어떻게 동작하는지 자세히 알고싶다면, 해당 언어에 해당하는 [[ In either case, if the message is serialized the unrecognized value will still be serialized with the message. ][코드 생성 가이드]]를 참고하세요.
*** reserved Values
	만약 enum 타입 값을 완전히 제거하거나 주석처리하여 enum을 업데이트 하면 향 후 사용자가 직접 업데이트 할 때 해당 숫자 값을 재사용 할 수 있습니다. ~.proto~ 파일의 이전버전을 사용할 경우 이는 데이터 손상, 개인 정보 보호 이슈 등등 심각한 문제가 발생할 수 있습니다. 삭제된 enum 값의 필드 번호(또는 json 직렬화 문제를 일으킬 수 있는 이름)를 ~예약~ 하도록 지정하면 이러한 문제가 발생하는 것을 피할 수 있습니다. 만약 향후 사용자가 예약된 enum 값의 식별자를 사용하려고 할 경우 프로토콜 버퍼 컴파일러가 경고를 해 줄 것입니다. ~max~ 키워드를 사용하면 예약 된 숫자 값 범위를 최대 값^(역자 주: 32bit integer의 최댓값)까지 지정할 수 있습니다.
   #+BEGIN_SRC proto
   enum Foo {
     reserved 2, 15, 9 to 11, 40 to max;
     reserved "FOO", "BAR";
   }
   #+END_SRC
   동일한 ~예약~ 구문에서는 필드 이름과 이름 번호를 혼용할 수 없습니다.
** Using Other Message Types
   다른 메세지 타입을 필드 타입으로 사용할 수 있습니다. 예를 들어, ~SearchResponse~ 메세지 타입에 ~Result~ 메세지 타입을 포함하고 싶다고 가정해봅시다. 우리는 ~Result~ 메세지 타입을 동일한 ~.proto~ 파일에 정의한 후 ~SearchResposne~ 안에 ~Result~ 필드 타입을 명시하기만 하면 됩니다.
   #+BEGIN_SRC proto
   message SearchResponse {
     repeated Result results = 1;
   }

   message Result {
     string url = 1;
     string title = 2;
     repeated string snippets = 3;
   }
   #+END_SRC
*** Importing Definitions
	위 예제에서, ~Result~ 메세지는 ~SearchResponse~ 메세지와 동일한 파일 안에 정의되었습니다. 만약 다른 ~.proto~ 파일 안에 정의된 메세지를 필드 타입으로 사용하고 싶을 경우엔 어떻게 해야 할까요?

	다른 ~.proto~ 파일을 사용하고 싶을 땐 /importing/ 문법을 사용할 수 있습니다. 다른 ~.proto~ 파일을 import 할 땐 당신의 파일에 import 구문을 넣으면 됩니다.
   #+BEGIN_SRC proto
   import "myproject/other_protos.proto";
   #+END_SRC
   기본적으로 당신은 ~.proto~ 파일을 직접 import 하는 방법만 사용할 수 있습니다. 그치만 당신은 가끔씩 `.proto` 파일을 다른 위치로 옮겨야 할 때가 있습니다. ~.proto~ 파일을 직접 이동하고 모든 참고를 한번에 업데이트 하는 대신, 더미 ~.proto~ 파일을 기존 위치에 두어 `import public` 구문을 통해 모든 import를 옮겨진 새 위치로부터 가져올 수 있습니다. ~import public~ 개념은 import 된 다른 파일의 `import public` 문법에 의존적입니다. 예를 들어봅시다.
   #+BEGIN_SRC proto
   // new.proto
   // All definitions are moved here
   #+END_SRC
   #+BEGIN_SRC proto
   // old.proto
   // This is the proto that all clients are importing.
   import public "new.proto";
   import "other.proto";
   #+END_SRC
   #+BEGIN_SRC proto
   // client.proto
   import "old.proto";
   // You use definitions from old.proto and new.proto, but not other.proto
   #+END_SRC
   프로토콜 컴파일러는 명령어 실행 시 ~-I~ / ~-proto_path~ 옵션을 사용하여 지정된 폴더들 안에서 import 된 파일들을 찾아옵니다. 만약 옵션을 지정하지 않은 경우엔 현재 컴파일러가 실행된 폴더를 기준으로 파일들을 찾아옵니다. ~--proto_path~ 옵션을 당신의 프로젝트 루트로 설정하고 모든 import문에 명시된 파일들을 가져오는 게 보통입니다.
*** Using proto2 Message Types
	proto2 메세지 타입을 proto3 메세지에 가져와서 사용하는 게 가능하고, 그 반대도 가능합니다. 그러나 proto2의 enum 타입은 proto3 구문에서 직접적으로 사용할 수 없습니다(import한 proto2 메세지에서 사용하는 경우는 괜찮습니다).
** Nested Types
   다른 메세지 타입 안에서 메세지 타입을 정의하고 사용할 수 있습니다. 아래의 예제에선 ~Result~ 메세지를 `SearchResponse` 메세지 안에서 정의하고 있습니다.
   #+BEGIN_SRC proto
   message SearchResponse {
     message Result {
       string url = 1;
       string title = 2;
       repeated string snippets = 3;
     }
     repeated Result results = 1;
   }
   #+END_SRC
   만약 부모 메세지 타입 밖에서 해당 메세지를 재사용 하고 싶다면 ~Parent.Type~ 처럼 사용할 수 있습니다.
   #+BEGIN_SRC proto
   message SomeOtherMessage {
     SearchResponse.Result result = 1;
   }
   #+END_SRC
   원하는 만큼 메세지를 중첩할 수 있습니다.
   #+BEGIN_SRC proto
   message Outer {                  // Level 0
     message MiddleAA {  // Level 1
       message Inner {   // Level 2
         int64 ival = 1;
         bool  booly = 2;
       }
     }
     message MiddleBB {  // Level 1
       message Inner {   // Level 2
         int32 ival = 1;
         bool  booly = 2;
       }
     }
   }
   #+END_SRC
** Updating A Message Type
   기존에 존재하는 메세지 타입이 더이상 요구사항을 충족하지 못하는 경우가 생길 수 있습니다. 예를 들어, 메세지 타입 형식은 유지하고 새로운 필드 타입을 추가하여 메세지 타입을 업데이트 하는 것은 매우 간단합니다. 아래의 규칙을 따라주세요.
   + 기존에 존재하는 필드 번호를 변경하지 마세요
   + 만약 당신이 새 필드를 추가해도 기존의 메세지들도 여전히 새로 생성된 코드를 통해서 파싱 후 직렬화 될 것입니다. 새로 추가된 코드와 기존 코드가 잘 상호작용 할 수 있도록 [[https://developers.google.com/protocol-buffers/docs/proto3#default][기본값]]에 신경쓰세요. 새 코드로 작성된 메세지는 여전히 기존 코드를 파싱할 수 있습니다. 기존 코드는 새로 추가된 필드를 무시합니다. 자세한 내용은 [[https://developers.google.com/protocol-buffers/docs/proto3#unknowns][알 수 없는 필드]] 섹션을 참고하세요.
   + 메세지 필드는 제거할 수 있지만, 해당 필드 번호가 추 후 재사용 되지 않도록 주의해야 합니다.
   + 필드 이름을 바꾸고 싶다면 필드 이름 앞에 "OBSOLETE_" 접두사를 추가하거나 필드 번호를 예약하여 향 후 ~.proto~ 사용자가 실수로라도 번호를 재사용 할 수 없도록 할 수 있습니다.
   + ~int32~, ~uint32~, ~int64~, ~uint64~, ~bool~ 타입은 모두 호환 가능합니다. 이 말은 이러한 필드 타입을 변형 없이 다른 필드 타입으로 변경할 수 있다는 뜻입니다^(역자 주: int32 -> uint32 또는 int64 -> uint64 변경 가능). 만약 규격을 벗어난 숫자를 타입 변경하면 C++ 언어에서 해당 타입으로 숫자를 캐스팅 한 것과 같은 효과를 얻을 수 있습니다(예: 64비트 숫자를 int32로 읽은 경우, 32bit로 잘립니다).
   + ~sint32~, ~sint64~ 필드는 서로 호환되지만 다른 integer 타입과는 호환되지 않습니다.
   + ~string~, ~bytes~ 타입의 경우 bytes 타입이 유효한 UTF-8 값이면 서로 호환됩니다.
   + 메세지 필드 타입의 경우 bytes에 인코딩 된 메세지의 버전이 포함되어 있는 경우 bytes와 호환됩니다.
   + ~fixed32~ 타입은 ~sfixed32~ 타입과 호환됩니다. 그리고 ~fixed64~ 타입은 ~sfixed64~ 필드와 호환됩니다.
   + ~enum~ 타입은 ~int32~, ~uint32~, ~int64~, ~uint64~ 필드와 유효한 값 범위 내에서 호환됩니다(값이 만약 범위를 벗어날 경우 숫자가 잘립니다). 그러나 메세지가 역직렬화 될 때 클라이언트 코드가 코드를 다르게 취급할 수 있습니다. 예를 들어, 인식할 수 없는 proto3 버전의 ~enum~ 타입은 메세지에 보존되지만 메세지가 역질렬화 할 때 이 값이 어떻게 표현되는지는 언어에 따라 다릅니다. Int 필드는 항상 값을 유지해야 합니다.
   + 단일 값을 새 값의 멤버로 변경하는 것은 안전하고 바이너리 호환이 가능합니다. 두 개 이상의 필드가 코드에 한번에 셋팅되지 않은 경우엔 여러 개의 기존 필드를 새 필드로 안전하게 옮길 수 있습니다. 특정 필드를 기존 필드로 옮기는 것은 안전하지 않습니다.
