#+TITLE: tinode series.003 - API document
#+SUBTITLE: tinode chat API document 한국어 번역본
#+LAYOUT: post
#+AUTHOR: yeongcheon
#+DATE: 2020-07-26 00:00:00 +0900
#+TAGS[]: tinode golang chat 
#+DRAFT: true

매번 [[https://github.com/tinode/chat/blob/master/docs/API.md][영어문서]] 보기 빡쳐서 직접 번역기 돌려가며 쓰는 번역본. +번역기와 의역, 오역 범벅입니다.+ 가급적이면 [[https://github.com/tinode/chat/blob/master/docs/API.md][공식 문서]]를 보세요.

* Server API
** How it works?
   Tinode는 IM 라우터이자 스토어입니다. 발행-구독 모델 컨셉을 대략적으로 따릅니다.

   서버는 세션, 사용자, 그리고 토픽을 연결합니다. 세션은 클라이언트 프로그램과 서버 간의 네트워크 연결을 의미합니다. 사용자는 세션을 서버에 연결하는 사람을 의미합니다. 토픽은 세션들끼리 콘텐츠를 주고받는 통신 채널입니다.

   사용자가 토픽은 각각 고유한 ID가 할당됩니다. 사용자 ID는 'usr' 문자로 시작하는 base64-URL 인코딩 6비트 랜덤 문자로 이루어져 있습니다(예: usr2il9suCbuko). 토픽 ID는 아래에서 설명합니다.

   모바일 또는 웹 어플리케이션 클라이언트는 웹소켓 또는 long pulling 방식으로 서버에 연결하여 세션을 생성합니다. 대부분 작업을 수행하기 위해선 클라이언트 인증이 필요합니다. 클라이언트는 {login} 패킷을 전송하여 세션을 인증합니다. 좀 더 자세한 내용은 [[#Authentication][인증 섹션]]을 참고하세요. 인증되면 클라이언트는 나중에 인증에 사용할 토큰을 발급받습니다. 동일한 사용자가 여러 세션을 동시에 설정할 수 있습니다. 로그아웃은 지원하지 않습니다. (필요하지도 않고요).

   세션이 설정되면 사용자는 토픽을 통해 다른 사용자와 통신을 시작할 수 있습니다. 다음과 같은 토픽들을 사용할 수 있습니다.
  
   + ~me~ 는 자기 자신의 프로필을 관리하고 다른 토픽에 대한 알람을 받을 수 있는 토픽입니다. ~me~ 토픽은 모든 사용자가 가지고 있습니다.
   + ~fnd~ 토픽은 다른 사용자나 토픽을 찾을 때 사용합니다. ~fnd~ 토픽 또한 모든 사용자가 가지고 있습니다.
   + Peer to Peer 토픽은 두 사용자 간 1:1 통신을 위한 토픽입니다. 각 사용자는 토픽 이름을 상대방의 ID로 인지합니다. 즉, 'usr' 문자로 시작하는 base64-URL 인코딩 6비트 랜덤 문자(예: usr2il9suCbuko)로 인지합니다.
   + 그룹 토픽은 여러 사용자 간 통신을 위한 토픽입니다. 이 토픽의 이름은 'grp'로 시작하며 11자리의 pseudo 무작위 숫자로 이루어져 있습니다(예: ~grpYiqEXb4QY6s~). 그룹 토픽은 반드시 명시적으로 작성해야 합니다.

   세션은  ~{sub}~ 패킷을 전송하여 토픽에 참여합니다. ~{sub}~ 패킷은 세 가지 기능을 제공합니다. 새 토픽을 만들고, 사용자 토픽을 구독하고, 세션을 토픽에 연결하는 기능을 제공합니다. 더 자세한 내용은 아래 [[#sub][~{sub}~]] 섹션을 참고하세요.

   세션이 토픽에 연결되면, 사용자는 ~{pub}~ 패킷을 이용해 콘텐츠를 생성을 시작합니다. 콘텐츠는 다른 세션들에게 ~{data}~ 패킷 형태로 전송됩니다.

   사용자는 ~{get}~, ~{set}~ 패킷을 이용하여 쿼리를 요청하거나, 토픽의 메타데이터를 수정할 수 있습니다.

   토픽의 설명 변경 또는 다른 사용자의 토픽 참여, 탈퇴 같은 토픽 메타데이터 변경은 ~{pres}~ (presence) 패킷을 이용하여 실시간으로 세션에 전송합니다. ~{pres}~ 패킷은 연관있는 토픽 또는 ~me~ 토픽으로 전송됩니다.

  사용자의 ~me~ 토픽이 온라인 상태가 되면(예: 인증된 세션이 ~me~ 토픽과 연결될 때) ~{pres}~ 패킷이 온라인 된 사용자와 Peer to Perr 형태로 연결된 모든 사용자의 ~me~ 토픽에 전송됩니다.
** General Considerations
   타임스탬프는 항상 [[https://tools.ietf.org/html/rfc3339][RFC 3339]] 형식을 따르는 문자열 형태이며, 밀리 세컨드까지 표시되고 타임존은 항상 UTC를 기준으로 한다. 예: ~"2015-10-06T18:07:29.841Z"~

   앞으로 이 문서에서 base64 인코딩이 언급된다면, 이는 padding characters가 stripped된 base64 URL인코딩을 의미합니다. [[https://tools.ietf.org/html/rfc4648][RFC 4648]] 문서를 참고하세요.

   ~{data}~ 패킷은 서버에서 생성한 순차적 ID를 가집니다. ID는 1부터 시작하여 각 메세지마다 1씩 증가하는 10진수 형태의 숫자입니다. 각 ID는 토픽별로 고유한 값임을 보장합니다. 요청에 대한 응답을 연동하기 위해서 클라이언트는 서버에 할당된 모든 패캣에 메세지 ID를 할당할 수 있습니다. 이 ID는 클라이언트 측에서 정의한 고유한 문자열 값입니다. 클라이언트는 이 ID값을 각 세션별로 고유하게(unique) 만들어야 합니다. 클라이언트가 할당한 아이디는 서버에서는 신경쓰지 않으며, 클라이언트에 그대로 반환됩니다.   
   
** Connecting to the Server 
   네트워크에서 서버에 연결하는 방법은 3가지가 있습니다. 웹 소켓, 롱 폴링, 그리고 [[https://grpc.io/][gRPC]]입니다.

   클라이언트가 웹 소켓이나 롤 폴링같은 방식으로 HTTP(S)를 통해 서버와 연결 됐을 때, 서버는 다음과 같은 endpoint를 제공합니다.

   + ~/v0/channels~ 는 웹 소켓 연결 시 사용됩니다.
   + ~/v0/channels/lp~ 는 롱 폴링 연결 시 사용됩니다.
   + ~/v0/file/u~ 는 파일 업로드 시 사용됩니다.
   + ~/v0/file/s~ 는 파일 다운로드에 사용됩니다.

   ~v0~ 은 API 버전을 나타냅니다(현재 버전 0). 모든 HTTP(S) 요청은 API 키가 포함되어 있어야 합니다. 서버는 아래의 순서대로 API 키를 확인합니다.

   + HTTP header ~X-Tinode-APIKey~
   + URL query parameter ~apikey~(/v0/file/s/abcdefg.jpeg?apikey=...)
   + Form value ~apikey~
   + Cookie ~apikey~

   편의상 모든 데모 앱에는 기본 API 키가 포함되어 있습니다. [[https://github.com/tinode/chat/tree/master/keygen][~keygen~ 유틸리티]]를 사용하여 프로덕션용 고유 키를 생성하세요.

   서버에 연결되면 클라이언트는 서버에 ~{hi}~ 메세지를 전송해야 합니다. 서버는 이에 성공 또는 에러를 나타내는 ~{ctrl}~ 메세지로 응답합니다. 응답의 ~param~ 필드는 서버의 프로토콜 버전 ~"params": {"ver":"0,15"}~ 를 포함하며, 다른 값을 포함할 수 있습니다.

*** gRPC
	[[https://github.com/tinode/chat/blob/master/pbx/model.proto][proto file]]에서 gRPC API가 어떻게 정의되어 있는지 확인하세요. gRPC API는 루트 사용자가 다른 사용자들 대신해서 메세지를 보내거나 사용자를 삭제하는 등 이 문서에서 설명하는 내용보다 좀 더 많은 기능을 가지고 있습니다. 

	protoubf의 message의 ~bytes~ 필드에는 JSON 인코딩 UTF-8 콘텐츠가 필요합니다. 예를 들어, 문자열은 반드시 UTF-8 bytes로 변환되기 전에 따옴표로 감싸져 있어야 합니다.(Go: ~[]byte("\"\some string"")~), (Python 3: ~'"another string".encode('utf-8')'~)
*** WebSocket
	모든 메세지들은 각 메세지마다 하나의 텍스트 프레임으로 전송됩니다. 바이너리 형식은 추 후에 사용하기 위해 예약되어 있습니다. 기본적으로 서버는 Origin 헤더에 값이 있는 연결을 허용합니다.

*** Long Polling
	롱 폴링은 ~HTTP POST~ 또는 ~GET~ 메소드로 연결됩니다(POST를 권장). 클라이언트의 첫 번째 요청에 대한 응답으로 서버는 ~params~ 에 ~sid~(세션 ID) 값을 포함하는 ~{ctrl}~ 메세지를 전송합니다. 롱 폴링 클라이언트는 첫 번째 이후 모든 요청에 URL 또는 request body에 ~sid~ 를 포함하여야 합니다.

	서버는 모든 origin에 대하여 연결을 허용합니다. 예: ~Access-Control-Allow-Origin: *~

*** Out of Band Large Files
	대용량 파일은 ~HTTP POST~, ~Content-Type: multipart/form-data~ 를 사용하여 전송됩니다. 자세한 내용은 [[#Out-of-Band Handling of Large Files][여기]]를 참고하세요.

*** Running Behind a Reverse Proxy
	Tinode 서버는 NGINX와 같은 리버스 프록시 환경에서도 실행되도록 설정할 수 있습니다. 효율성을 위해 unix 소켓 파일 경로를 설정하여 unix 소켓을 통해 일반 연결, 또는 grpc 연결 등을 허용할 수 있습니다. 예:~unix:/run/tinode.sock~. ~use_x_forwarded_for~ 설정 파라메터를 ~true~ 로 설정하여 ~X-Forwarded-For~ HTTP 헤더에서 클라이언트의 IP 주소를 읽도록 서버를 구성 할 수도 있습니다.

* Users
  사용자(User)는 실제 사람, 즉 메세지를 만들고 사용하는 사람을 의미합니다.
  
  사용자에겐 일반적으로 두 가지 인증 레벨이 있는데, 인증(~auth~), 익명(~anon~)이 있습니다. 이 외의도 ~root~ 레벨이 있는데 이 레벨은 ~gRPC~ 를 통해서면 접근할 수 있고 ~root~ 사용자는 다른 사용자 대신 메세지를 보낼 수 있습니다.

  처음 연결될 때 클라이언트 애플리케이션은 ~{acc}~ 또는 ~{login}~ 메세지를 보내 사용자를 인증할 수 있습니다.

  사용자는 저마다 고유의 ID값을 가지고 있습니다. 이 ID값은 ~user~ 로 시작하는 base64-encoded 64-bit numeric 값입니다(예: ~usr2il9suCbuko~). 사용자는 또한 아래의 속성들을 지닙니다.

  + ~created~: 사용자 레코드가 생성된 시간(timestamp)
  + ~updated~: 사용자의 ~public~ 값이 갱신된 시간(timestamp)
  + ~status~: 사용자 계정의 상태
  + ~username~: ~base~ 인증(ID/PW login)에 사용되는 고유한 값입니다. username은 다른 사용자가 볼 수 없습니다.
  + ~defacs~: 인증 사용자나 익명 사용자와 P2P 대화를 위한 사용자의 기본 액세스 모드를 설명하는 개체입니다. 자세한 내용은 [[#Access Control][Access control]]을 참고하세요.
	- ~auth~: ~auth~ 사용자를 위한 기본 액세스 모드
	- ~anon~: ~anon~ 사용자를 위한 기본 액세스 모드
  + ~public~: 애플리케이션에서 정의한 사용자에 대한 정보가 담긴 오브젝트. 누구든지 쿼리문을 이용해 ~public~ 데이터를 조회할 수 있습니다.
  + ~private~: 애플리케이션에서 정의한 사용자에 대한 고유한 정보가 담긴 오브젝트. 오직 자기 자신만 조회할 수 있습니다.
  + ~tags~: [[#fnd][discovery]] and credentials.

  사용자 계정은 상태값을 가집니다. 상태값 종류는 다음과 같습니다.

  + ~ok~ (normal): 기본 상태, 계정에 아무런 제약이 없고 정상적인 상태임을 의미합니다.
  + ~susp~ (suspended): 사용자를 [[#fnd][검색]]을 통해서도 찾을 수 없을뿐만 아니라 계정에 접근 자체를 할 수 없는 상태를 의미합니다. 관리자가 상태를 복구할 수 있습니다.
  + ~del~ (soft-deleted): 사용자가 삭제 처리되었지만 데이터는 존재하는 상태를 의미합니다. 사용자 삭제는 현재 지원하지 않습니다.
  + ~undef~ (undefined): 관리자가 내부적으로 사용합니다. 다른 곳에서 사용해서는 안됩니다.

  사용자는 서버에 동시에 여러 개의 연결(세션)을 유지할 수 있습니다. 각 세션에는 클라이언트에서 제공하는 ~User-Agent~ 태그가 달리며 이 태그값은 클라이언트 소프트웨어별로 다릅니다.

  로그아웃은 애초에 설계단계부터 지원하지 않았습니다. 만약 애플리케이션에서 사용자를 전환해야 한다면, 새 사용자 인증을 이용해 연결을 새로 하기만 하면 됩니다.
  
** Authentication
   :PROPERTIES:
   :CUSTOM_ID: Authentication
   :END:
   인증(Authentication)은 [[https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer][SASL]]과 컨셉이 매우 유사합니다. 각각 다른 인증 방법을 구현할 수 있도록 어댑터를 제공하고 있습니다. 인증 구현체(Authenticators)는 [[#acc][~{acc}~]] 를 이용해 사용자를 등록하거나 [[#login][~{login}~]] 을 할 때 사용됩니다. 서버는 다음과 같은 인증 방법을 제공합니다.

   + ~token~ 방식은 암호화된 토큰을 이용해 인증합니다.
   + ~basic~ 방식은 login-password 인증합니다.
   + ~anonymous~ 방식은 채팅을 통한 고객 지원 요청 처리와 같은 임시 사용자를 위해 디자인 되었습니다.
   + ~rest~ 방식은 JSON RPC를 통해 외부 인증 시스템을 사용할 수 있도록 하는 [[https://github.com/tinode/chat/tree/master/server/auth/rest][meta-method]]입니다.

   이 외에 다른 인증 방식도 어댑터를 직접 구현하여 사용할 수 있습니다.

   ~token~ 은 기본 인증 방식으로 사용합니다. 이 토큰들은 토큰 인증에 가볍게 사용할 수 있도록 설계되었습니다. 예를 들어, 토큰 인증모듈(authenticator)는 일반적으로 데이터베이스에 접근하지 않고 모든 작업을 메모리 안에서 처리합니다. 다른 모든 인증 방법은 토큰을 얻거나 갱신하는데만 사용합니다. 일단 토큰이 확보되면 이 후 로그인 작업에서 이를 사용합니다.

   ~basic~ 인증 모듈은 username:password 형식의 문자열을 base64-encoded을 이용해 암호화 된 문자열을 사용합니다. 이때 username은 콜론문자(:)를 포함하지 않아야 합니다(ASCII 0X3A).

   ~anonymous~ 계정을 만들 때 사용할 수 있으며, 로그인에는 사용할 수 없습니다. 사용자는 ~anonymous~ 인증 체계를 사용하여 계정을 만들고 해당 계정에 로그인 할 수 있는 암호화 된 토큰을 얻습니다. 이 토큰을 잃어버리거나 만료되면 사용자는 더이상 해당 계정에 액세스 할 수 없습니다.

   컴파일 된 인증 모듈은 설정 파일의 ~logical_names~ 값을 수정하여 변경할 수 있습니다. 예를 들어, 별도 제작된 ~rest~ 인증 모듈을 ~basic~ 인증 모듈을 대신해서 사용하거나 ~token~ 인증 모듈을 사용자로부터 숨길 수 있습니다. 이 기능은 설정 파일의 ~logical_name:actual_name~ 에서 actual_name 값을 바꾸거나 ~actual_name:~ 값을 숨겨서 활성화 할 수 있습니다. 예를 들어, 기본 인증에 ~rest~ 서비스를 사용하고 싶으면 ~"logical_names":["basic:rest"]~ 처럼 설정하면 됩니다.

*** Creating an Account
	새 계정을 만들 때, 사용자는 서버에 나중에 해당 계정에 접근할 인증 방법을 등록해야 합니다. 계정 생성은 ~basic~, ~anonymous~ 인증만 사용할 수 있습니다. ~basic~ 인증은 고유 아이디 및 비밀번호를 서버에 등록해야 합니다. ~anonymous~ 는 인증 관련 내용을 등록하지 않습니다.

	사용자가 ~{acc login=true}~ 를 셋팅했다면 즉시 인증을 위해 새 계정을 사용할 수 있습니다. ~login=false~ 일 경우엔(또는 설정되지 않았다면) 새 계정은 생성되지만 계정을 생성한 세션의 인증 상태는 변경되지 않습니다. ~login=true~ 일 경우 서버는 생성된 새 계정으로 세션 인증을 시도하고 {acc} 요청에 대한 성공 응답에는 인증 토큰이 포함됩니다. 이 룰은 익명 인증 시에 특히 중요합니다.	

*** Logging in
	로그인은 ~{login}~ 요청을 통해서 실행됩니다. 로그인은 ~basic~, ~token~ 인증을 통해서만 가능합니다. 모든 로그인은 200 코드와 ~token~ 인증에 사용할 토큰을 ~{ctrl}~ 메세지를 통해 응답 받거나, 300 코드와 추가 인증과 메소드 종속 문제, 또는 4xx 코드와 추가 정보를 요청합니다.^(역자 주: 의역이에요.)

	토큰에는 서버 구성 만료 시간이 있으므로 주기적으로 갱신해야 합니다.

*** Changing Authentication Parameters
	:PROPERTIES:
	:CUSTOM_ID: Changing Authentication Parameters
	:END:
	사용자가 아이디나 패스워드같은 인증 관련 파라메터를 변경하려면 ~{acc}~ 사용해서 요청을 해야한다. 현재는 ~basic~ 인증만 지원한다.

	#+BEGIN_SRC json
acc: {
  id: "1a2b3", // string, client-provided message id, optional
  user: "usr2il9suCbuko", // user being affected by the change, optional
  token: "XMg...g1Gp8+BO0=", // authentication token if the session
                             // is not yet authenticated, optional.
  scheme: "basic", // authentication scheme being updated.
  secret: base64encode("new_username:new_password") // new parameters
}
	#+END_SRC

	패스워드만 바꾸고 싶다면, ~username~ 필드는 비워놓아야 한다(예: ~secret: base64encode("new_password")~).

	세션이 인증되지 않은 상태라면, request는 무조건 ~token~ 을 포함하고 있어야 한다. 이 ~token~ 은 로그인을 통해 얻은 일반 인증 토큰이거나, [[#resetting a password][비밀번호 재설정]] 작업을 통해 얻는 토큰일 수 있습니다. 세션이 인증되면 ~token~ 을 포함하지 않아야 합니다. 만약 ~ROOT~ 레벨로 인증했다면 ~user~ 값에 다른 유효한 사용자의 ID값을 셋팅할 수 있습니다. 그렇지 않다면 이 값을 빈 값으로 유지하거나(기본값: 현재 사용자) 자기 자신의 ID값을 할당해야 합니다.

*** Resetting a Password, i.e. "Forgot Password"
    :PROPERTIES:
    :CUSTOM_ID: resetting a password
    :END:
    아이디나 비밀번호를 초기화 할 때(또는 인증 모듈이 지원하는 인증용 시크릿 토큰), ~{login}~ 메세지를 ~scheme~, ~reset~, 그리고 base64-encoded 문자값("~authentication scheme to reset secret for~:~reset method~:~reset method value~")을 포함한 ~secret~ 값을 전송합니다. 가장 일반적인 케이스로 이메일의 비밀번호 수정을 하는 코드는 아래와 같습니다.

	#+BEGIN_SRC
login: {
  id: "1a2b3",
  scheme: "reset",
  secret: base64encode("basic:email:jdoe@example.com")
}
	#+END_SRC

	여기서 ~jdoe@example.com~ 은 이전에 검증된 사용자의 이메일입니다.

	이메일이 등록된 데이터와 일치하면, 서버는 비밀번호를 재설정 하기 위한 지시 사항과 함께 지정된 방법 및 주소를 사용하여 메세지를 보냅니다. [[#Changing Authentication Parameters][Changing Authentication Parameters]] 섹션에 설명된대로 이메일에는 ~{acc}~ request에 포함할 수 있는 시크릿 코드가 포함되어 있습니다.

** Suspending a User
   사용자 계정은 관리자에 의해 정지될 수 있습니다. 계정이 정지되면 사용자는 더이상 로그인 할 수 없고 서비스도 이용할 수 없습니다.

   ~root~ 사용자만이 다른 계정을 정지시킬 수 있습니다. 관리자에 의해 계정이 정지된 사용자는 아래의 메세지를 받습니다.

   #+BEGIN_SRC
acc: {
  id: "1a2b3", // string, client-provided message id, optional
  user: "usr2il9suCbuko", // user being affected by the change
  status: "suspended"
}
   #+END_SRC

   정지가 해제된 계정은 위와 동일한 메세지를 수신하지만 ~status: "ok"~ 값이 담긴 메세지를 수신합니다. 관리자는 ~{get what="desc"}~ 커맨드를 실행하여 사용자의 ~me~ topic을 조회할 수 있습니다.

** Credential Validation
   서버는 필요하다면 특정 인증 체계를 이용한 사용자 계정 인증 기능을 선택적으로 구성할 수 있습니다. 예를 들어, 사용자에게 고유한 이메일, 전화번호 등을 제공하도록 요구하거나 계정 등록 조건으로 보안 문자를 해결하도록 요구할 수 있습니다.

   서버는 약간의 설정 변경만으로 이메일 인증을 지원할 수 있습니다. 대부분 잘 동작하며, 문자 메세지를 보내기 위해서는 별도 상용 서비스가 필요하기 때문에  전화번호 인증 기능은 제대로 동작하지 않습니다.

   자격 증명이 활성화 된 상태일 경우, 사용자는 항상 유효성 검사에 통과된 상태여야 합니다. 필수 자격 증명을 변경해야 하는 경우엔 사용자가 먼저 새 자격 증명을 추가하고 유효성 검사를 한 다음 이전 자격 증명을 제거해야 합니다.

   자격 증명은 ~{acc}~ 메세지를 보내 할당되고, ~{set topic="me"}~ 를 통해 추가되고, ~del topic="me"~ 를 통해서 삭제됩니다. 자격 증명은 ~{login}~ 또는 ~{acc}~ 메세지를 전송하여 클라이언트 측에서 확인됩니다.

** Access Control
:PROPERTIES:
:CUSTOM_ID: Access Control
:END:
* Topics 
** ~me~ Topic
** ~fnd~ and Tags: Finding Users and Topics
:PROPERTIES:
:CUSTOM_ID: fnd
:END:
*** Query Language
*** Incremental Updates to Queries
*** Query Rewrite
*** Possible Use Cases
** Peer to Peer Topics
** Group Topics
** ~sys~ Topic
* Using Server-Issued Message IDs
* User Agent and Presence Notifications
* Public and Private Fields 
** Public
** Private
* Format of Content
* Out-of-Band Handling of Large Files 
:PROPERTIES:
:CUSTOM_ID: Out-of-Band Handling of Large Files 
:END:
** Uploading
** Downloading
* Push Notifications 
** Tinode Push Gateway
** Google FCM
** Stdout
* Messagse
** Client to Server Messages 
*** ~{hi}~
*** ~{acc}~
:PROPERTIES:
:CUSTOM_ID: acc
:END:
*** ~{login}~
:PROPERTIES:
:CUSTOM_ID: login
:END:
*** ~{sub}~
:PROPERTIES:
:CUSTOM_ID: sub
:END:
*** ~{leave}~
*** ~{pub}~
*** ~{get}~
*** ~{set}~
*** ~{del}~
*** ~{note}~
** Server to Client Messages 
*** ~{data}~
*** ~{ctrl}~
*** ~{meta}~
*** ~{pres}~
*** ~{info}~
