#+TITLE: tinode series.003 - API document
#+SUBTITLE: tinode chat API document 한국어 번역본
#+LAYOUT: post
#+AUTHOR: yeongcheon
#+DATE: 2020-07-26 00:00:00 +0900
#+TAGS[]: tinode golang chat 
#+DRAFT: true

매번 [[https://github.com/tinode/chat/blob/master/docs/API.md][영어문서]] 보기 빡쳐서 직접 번역기 돌려가며 쓰는 번역본. +번역기와 의역, 오역 범벅입니다.+ 가급적이면 [[https://github.com/tinode/chat/blob/master/docs/API.md][공식 문서]]를 보세요.

* Server API
** How it works?
   Tinode는 IM 라우터이자 스토어입니다. 발행-구독 모델 컨셉을 대략적으로 따릅니다.

   서버는 세션, 사용자, 그리고 토픽을 연결합니다. 세션은 클라이언트 프로그램과 서버 간의 네트워크 연결을 의미합니다. 사용자는 세션을 서버에 연결하는 사람을 의미합니다. 토픽은 세션들끼리 콘텐츠를 주고받는 통신 채널입니다.

   사용자가 토픽은 각각 고유한 ID가 할당됩니다. 사용자 ID는 'usr' 문자로 시작하는 base64-URL 인코딩 6비트 랜덤 문자로 이루어져 있습니다(예: usr2il9suCbuko). 토픽 ID는 아래에서 설명합니다.

   모바일 또는 웹 어플리케이션 클라이언트는 웹소켓 또는 long pulling 방식으로 서버에 연결하여 세션을 생성합니다. 대부분 작업을 수행하기 위해선 클라이언트 인증이 필요합니다. 클라이언트는 {login} 패킷을 전송하여 세션을 인증합니다. 좀 더 자세한 내용은 [[#Authentication][인증 섹션]]을 참고하세요. 인증되면 클라이언트는 나중에 인증에 사용할 토큰을 발급받습니다. 동일한 사용자가 여러 세션을 동시에 설정할 수 있습니다. 로그아웃은 지원하지 않습니다. (필요하지도 않고요).

   세션이 설정되면 사용자는 토픽을 통해 다른 사용자와 통신을 시작할 수 있습니다. 다음과 같은 토픽들을 사용할 수 있습니다.
  
   + ~me~ 는 자기 자신의 프로필을 관리하고 다른 토픽에 대한 알람을 받을 수 있는 토픽입니다. ~me~ 토픽은 모든 사용자가 가지고 있습니다.
   + ~fnd~ 토픽은 다른 사용자나 토픽을 찾을 때 사용합니다. ~fnd~ 토픽 또한 모든 사용자가 가지고 있습니다.
   + Peer to Peer 토픽은 두 사용자 간 1:1 통신을 위한 토픽입니다. 각 사용자는 토픽 이름을 상대방의 ID로 인지합니다. 즉, 'usr' 문자로 시작하는 base64-URL 인코딩 6비트 랜덤 문자(예: usr2il9suCbuko)로 인지합니다.
   + 그룹 토픽은 여러 사용자 간 통신을 위한 토픽입니다. 이 토픽의 이름은 'grp'로 시작하며 11자리의 pseudo 무작위 숫자로 이루어져 있습니다(예: ~grpYiqEXb4QY6s~). 그룹 토픽은 반드시 명시적으로 작성해야 합니다.

   세션은  ~{sub}~ 패킷을 전송하여 토픽에 참여합니다. ~{sub}~ 패킷은 세 가지 기능을 제공합니다. 새 토픽을 만들고, 사용자 토픽을 구독하고, 세션을 토픽에 연결하는 기능을 제공합니다. 더 자세한 내용은 아래 [[#sub][~{sub}~]] 섹션을 참고하세요.

   세션이 토픽에 연결되면, 사용자는 ~{pub}~ 패킷을 이용해 콘텐츠를 생성을 시작합니다. 콘텐츠는 다른 세션들에게 ~{data}~ 패킷 형태로 전송됩니다.

   사용자는 ~{get}~, ~{set}~ 패킷을 이용하여 쿼리를 요청하거나, 토픽의 메타데이터를 수정할 수 있습니다.

   토픽의 설명 변경 또는 다른 사용자의 토픽 참여, 탈퇴 같은 토픽 메타데이터 변경은 ~{pres}~ (presence) 패킷을 이용하여 실시간으로 세션에 전송합니다. ~{pres}~ 패킷은 연관있는 토픽 또는 ~me~ 토픽으로 전송됩니다.

  사용자의 ~me~ 토픽이 온라인 상태가 되면(예: 인증된 세션이 ~me~ 토픽과 연결될 때) ~{pres}~ 패킷이 온라인 된 사용자와 Peer to Perr 형태로 연결된 모든 사용자의 ~me~ 토픽에 전송됩니다.
** General Considerations
   타임스탬프는 항상 [[https://tools.ietf.org/html/rfc3339][RFC 3339]] 형식을 따르는 문자열 형태이며, 밀리 세컨드까지 표시되고 타임존은 항상 UTC를 기준으로 한다. 예: ~"2015-10-06T18:07:29.841Z"~

   앞으로 이 문서에서 base64 인코딩이 언급된다면, 이는 padding characters가 stripped된 base64 URL인코딩을 의미합니다. [[https://tools.ietf.org/html/rfc4648][RFC 4648]] 문서를 참고하세요.

   ~{data}~ 패킷은 서버에서 생성한 순차적 ID를 가집니다. ID는 1부터 시작하여 각 메세지마다 1씩 증가하는 10진수 형태의 숫자입니다. 각 ID는 토픽별로 고유한 값임을 보장합니다. 요청에 대한 응답을 연동하기 위해서 클라이언트는 서버에 할당된 모든 패캣에 메세지 ID를 할당할 수 있습니다. 이 ID는 클라이언트 측에서 정의한 고유한 문자열 값입니다. 클라이언트는 이 ID값을 각 세션별로 고유하게(unique) 만들어야 합니다. 클라이언트가 할당한 아이디는 서버에서는 신경쓰지 않으며, 클라이언트에 그대로 반환됩니다.   
   
** Connecting to the Server 
   네트워크에서 서버에 연결하는 방법은 3가지가 있습니다. 웹 소켓, 롱 폴링, 그리고 [[https://grpc.io/][gRPC]]입니다.

   클라이언트가 웹 소켓이나 롤 폴링같은 방식으로 HTTP(S)를 통해 서버와 연결 됐을 때, 서버는 다음과 같은 endpoint를 제공합니다.

   + ~/v0/channels~ 는 웹 소켓 연결 시 사용됩니다.
   + ~/v0/channels/lp~ 는 롱 폴링 연결 시 사용됩니다.
   + ~/v0/file/u~ 는 파일 업로드 시 사용됩니다.
   + ~/v0/file/s~ 는 파일 다운로드에 사용됩니다.

   ~v0~ 은 API 버전을 나타냅니다(현재 버전 0). 모든 HTTP(S) 요청은 API 키가 포함되어 있어야 합니다. 서버는 아래의 순서대로 API 키를 확인합니다.

   + HTTP header ~X-Tinode-APIKey~
   + URL query parameter ~apikey~(/v0/file/s/abcdefg.jpeg?apikey=...)
   + Form value ~apikey~
   + Cookie ~apikey~

   편의상 모든 데모 앱에는 기본 API 키가 포함되어 있습니다. [[https://github.com/tinode/chat/tree/master/keygen][~keygen~ 유틸리티]]를 사용하여 프로덕션용 고유 키를 생성하세요.

   서버에 연결되면 클라이언트는 서버에 ~{hi}~ 메세지를 전송해야 합니다. 서버는 이에 성공 또는 에러를 나타내는 ~{ctrl}~ 메세지로 응답합니다. 응답의 ~param~ 필드는 서버의 프로토콜 버전 ~"params": {"ver":"0,15"}~ 를 포함하며, 다른 값을 포함할 수 있습니다.

*** gRPC
	[[https://github.com/tinode/chat/blob/master/pbx/model.proto][proto file]]에서 gRPC API가 어떻게 정의되어 있는지 확인하세요. gRPC API는 루트 사용자가 다른 사용자들 대신해서 메세지를 보내거나 사용자를 삭제하는 등 이 문서에서 설명하는 내용보다 좀 더 많은 기능을 가지고 있습니다. 

	protoubf의 message의 ~bytes~ 필드에는 JSON 인코딩 UTF-8 콘텐츠가 필요합니다. 예를 들어, 문자열은 반드시 UTF-8 bytes로 변환되기 전에 따옴표로 감싸져 있어야 합니다.(Go: ~[]byte("\"\some string"")~), (Python 3: ~'"another string".encode('utf-8')'~)
*** WebSocket
	모든 메세지들은 각 메세지마다 하나의 텍스트 프레임으로 전송됩니다. 바이너리 형식은 추 후에 사용하기 위해 예약되어 있습니다. 기본적으로 서버는 Origin 헤더에 값이 있는 연결을 허용합니다.

*** Long Polling
	롱 폴링은 ~HTTP POST~ 또는 ~GET~ 메소드로 연결됩니다(POST를 권장). 클라이언트의 첫 번째 요청에 대한 응답으로 서버는 ~params~ 에 ~sid~(세션 ID) 값을 포함하는 ~{ctrl}~ 메세지를 전송합니다. 롱 폴링 클라이언트는 첫 번째 이후 모든 요청에 URL 또는 request body에 ~sid~ 를 포함하여야 합니다.

	서버는 모든 origin에 대하여 연결을 허용합니다. 예: ~Access-Control-Allow-Origin: *~

*** Out of Band Large Files
	대용량 파일은 ~HTTP POST~, ~Content-Type: multipart/form-data~ 를 사용하여 전송됩니다. 자세한 내용은 [[#Out-of-Band Handling of Large Files][여기]]를 참고하세요.

*** Running Behind a Reverse Proxy
	Tinode 서버는 NGINX와 같은 리버스 프록시 환경에서도 실행되도록 설정할 수 있습니다. 효율성을 위해 unix 소켓 파일 경로를 설정하여 unix 소켓을 통해 일반 연결, 또는 grpc 연결 등을 허용할 수 있습니다. 예:~unix:/run/tinode.sock~. ~use_x_forwarded_for~ 설정 파라메터를 ~true~ 로 설정하여 ~X-Forwarded-For~ HTTP 헤더에서 클라이언트의 IP 주소를 읽도록 서버를 구성 할 수도 있습니다.

* Users
  사용자(User)는 실제 사람, 즉 메세지를 만들고 사용하는 사람을 의미합니다.
  
  사용자에겐 일반적으로 두 가지 인증 레벨이 있는데, 인증(~auth~), 익명(~anon~)이 있습니다. 이 외의도 ~root~ 레벨이 있는데 이 레벨은 ~gRPC~ 를 통해서면 접근할 수 있고 ~root~ 사용자는 다른 사용자 대신 메세지를 보낼 수 있습니다.

  처음 연결될 때 클라이언트 애플리케이션은 ~{acc}~ 또는 ~{login}~ 메세지를 보내 사용자를 인증할 수 있습니다.

  사용자는 저마다 고유의 ID값을 가지고 있습니다. 이 ID값은 ~user~ 로 시작하는 base64-encoded 64-bit numeric 값입니다(예: ~usr2il9suCbuko~). 사용자는 또한 아래의 속성들을 지닙니다.

  + ~created~: 사용자 레코드가 생성된 시간(timestamp)
  + ~updated~: 사용자의 ~public~ 값이 갱신된 시간(timestamp)
  + ~status~: 사용자 계정의 상태
  + ~username~: ~base~ 인증(ID/PW login)에 사용되는 고유한 값입니다. username은 다른 사용자가 볼 수 없습니다.
  + ~defacs~: 인증 사용자나 익명 사용자와 P2P 대화를 위한 사용자의 기본 액세스 모드를 설명하는 개체입니다. 자세한 내용은 [[#Access Control][Access control]]을 참고하세요.
	- ~auth~: ~auth~ 사용자를 위한 기본 액세스 모드
	- ~anon~: ~anon~ 사용자를 위한 기본 액세스 모드
  + ~public~: 애플리케이션에서 정의한 사용자에 대한 정보가 담긴 오브젝트. 누구든지 쿼리문을 이용해 ~public~ 데이터를 조회할 수 있습니다.
  + ~private~: 애플리케이션에서 정의한 사용자에 대한 고유한 정보가 담긴 오브젝트. 오직 자기 자신만 조회할 수 있습니다.
  + ~tags~: [[#fnd][discovery]] and credentials.

  사용자 계정은 상태값을 가집니다. 상태값 종류는 다음과 같습니다.

  + ~ok~ (normal): 기본 상태, 계정에 아무런 제약이 없고 정상적인 상태임을 의미합니다.
  + ~susp~ (suspended): 사용자를 [[#fnd][검색]]을 통해서도 찾을 수 없을뿐만 아니라 계정에 접근 자체를 할 수 없는 상태를 의미합니다. 관리자가 상태를 복구할 수 있습니다.
  + ~del~ (soft-deleted): 사용자가 삭제 처리되었지만 데이터는 존재하는 상태를 의미합니다. 사용자 삭제는 현재 지원하지 않습니다.
  + ~undef~ (undefined): 관리자가 내부적으로 사용합니다. 다른 곳에서 사용해서는 안됩니다.

  사용자는 서버에 동시에 여러 개의 연결(세션)을 유지할 수 있습니다. 각 세션에는 클라이언트에서 제공하는 ~User-Agent~ 태그가 달리며 이 태그값은 클라이언트 소프트웨어별로 다릅니다.

  로그아웃은 애초에 설계단계부터 지원하지 않았습니다. 만약 애플리케이션에서 사용자를 전환해야 한다면, 새 사용자 인증을 이용해 연결을 새로 하기만 하면 됩니다.
  
** Authentication
   :PROPERTIES:
   :CUSTOM_ID: Authentication
   :END:
   인증(Authentication)은 [[https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer][SASL]]과 컨셉이 매우 유사합니다. 각각 다른 인증 방법을 구현할 수 있도록 어댑터를 제공하고 있습니다. 인증 구현체(Authenticators)는 [[#acc][~{acc}~]] 를 이용해 사용자를 등록하거나 [[#login][~{login}~]] 을 할 때 사용됩니다. 서버는 다음과 같은 인증 방법을 제공합니다.

   + ~token~ 방식은 암호화된 토큰을 이용해 인증합니다.
   + ~basic~ 방식은 login-password 인증합니다.
   + ~anonymous~ 방식은 채팅을 통한 고객 지원 요청 처리와 같은 임시 사용자를 위해 디자인 되었습니다.
   + ~rest~ 방식은 JSON RPC를 통해 외부 인증 시스템을 사용할 수 있도록 하는 [[https://github.com/tinode/chat/tree/master/server/auth/rest][meta-method]]입니다.

   이 외에 다른 인증 방식도 어댑터를 직접 구현하여 사용할 수 있습니다.

   ~token~ 은 기본 인증 방식으로 사용합니다. 이 토큰들은 토큰 인증에 가볍게 사용할 수 있도록 설계되었습니다. 예를 들어, 토큰 인증모듈(authenticator)는 일반적으로 데이터베이스에 접근하지 않고 모든 작업을 메모리 안에서 처리합니다. 다른 모든 인증 방법은 토큰을 얻거나 갱신하는데만 사용합니다. 일단 토큰이 확보되면 이 후 로그인 작업에서 이를 사용합니다.

   ~basic~ 인증 모듈은 username:password 형식의 문자열을 base64-encoded을 이용해 암호화 된 문자열을 사용합니다. 이때 username은 콜론문자(:)를 포함하지 않아야 합니다(ASCII 0X3A).

   ~anonymous~ 계정을 만들 때 사용할 수 있으며, 로그인에는 사용할 수 없습니다. 사용자는 ~anonymous~ 인증 체계를 사용하여 계정을 만들고 해당 계정에 로그인 할 수 있는 암호화 된 토큰을 얻습니다. 이 토큰을 잃어버리거나 만료되면 사용자는 더이상 해당 계정에 액세스 할 수 없습니다.

   컴파일 된 인증 모듈은 설정 파일의 ~logical_names~ 값을 수정하여 변경할 수 있습니다. 예를 들어, 별도 제작된 ~rest~ 인증 모듈을 ~basic~ 인증 모듈을 대신해서 사용하거나 ~token~ 인증 모듈을 사용자로부터 숨길 수 있습니다. 이 기능은 설정 파일의 ~logical_name:actual_name~ 에서 actual_name 값을 바꾸거나 ~actual_name:~ 값을 숨겨서 활성화 할 수 있습니다. 예를 들어, 기본 인증에 ~rest~ 서비스를 사용하고 싶으면 ~"logical_names":["basic:rest"]~ 처럼 설정하면 됩니다.

*** Creating an Account
	새 계정을 만들 때, 사용자는 서버에 나중에 해당 계정에 접근할 인증 방법을 등록해야 합니다. 계정 생성은 ~basic~, ~anonymous~ 인증만 사용할 수 있습니다. ~basic~ 인증은 고유 아이디 및 비밀번호를 서버에 등록해야 합니다. ~anonymous~ 는 인증 관련 내용을 등록하지 않습니다.

	사용자가 ~{acc login=true}~ 를 셋팅했다면 즉시 인증을 위해 새 계정을 사용할 수 있습니다. ~login=false~ 일 경우엔(또는 설정되지 않았다면) 새 계정은 생성되지만 계정을 생성한 세션의 인증 상태는 변경되지 않습니다. ~login=true~ 일 경우 서버는 생성된 새 계정으로 세션 인증을 시도하고 {acc} 요청에 대한 성공 응답에는 인증 토큰이 포함됩니다. 이 룰은 익명 인증 시에 특히 중요합니다.	

*** Logging in
	로그인은 ~{login}~ 요청을 통해서 실행됩니다. 로그인은 ~basic~, ~token~ 인증을 통해서만 가능합니다. 모든 로그인은 200 코드와 ~token~ 인증에 사용할 토큰을 ~{ctrl}~ 메세지를 통해 응답 받거나, 300 코드와 추가 인증과 메소드 종속 문제, 또는 4xx 코드와 추가 정보를 요청합니다.^{(역자 주: 의역이에요.)}

	토큰에는 서버 구성 만료 시간이 있으므로 주기적으로 갱신해야 합니다.

*** Changing Authentication Parameters
	:PROPERTIES:
	:CUSTOM_ID: Changing Authentication Parameters
	:END:
	사용자가 아이디나 패스워드같은 인증 관련 파라메터를 변경하려면 ~{acc}~ 사용해서 요청을 해야한다. 현재는 ~basic~ 인증만 지원한다.

	#+BEGIN_SRC json
acc: {
  id: "1a2b3", // string, client-provided message id, optional
  user: "usr2il9suCbuko", // user being affected by the change, optional
  token: "XMg...g1Gp8+BO0=", // authentication token if the session
                             // is not yet authenticated, optional.
  scheme: "basic", // authentication scheme being updated.
  secret: base64encode("new_username:new_password") // new parameters
}
	#+END_SRC

	패스워드만 바꾸고 싶다면, ~username~ 필드는 비워놓아야 한다(예: ~secret: base64encode("new_password")~).

	세션이 인증되지 않은 상태라면, request는 무조건 ~token~ 을 포함하고 있어야 한다. 이 ~token~ 은 로그인을 통해 얻은 일반 인증 토큰이거나, [[#resetting a password][비밀번호 재설정]] 작업을 통해 얻는 토큰일 수 있습니다. 세션이 인증되면 ~token~ 을 포함하지 않아야 합니다. 만약 ~ROOT~ 레벨로 인증했다면 ~user~ 값에 다른 유효한 사용자의 ID값을 셋팅할 수 있습니다. 그렇지 않다면 이 값을 빈 값으로 유지하거나(기본값: 현재 사용자) 자기 자신의 ID값을 할당해야 합니다.

*** Resetting a Password, i.e. "Forgot Password"
    :PROPERTIES:
    :CUSTOM_ID: resetting a password
    :END:
    아이디나 비밀번호를 초기화 할 때(또는 인증 모듈이 지원하는 인증용 시크릿 토큰), ~{login}~ 메세지를 ~scheme~, ~reset~, 그리고 base64-encoded 문자값("~authentication scheme to reset secret for~:~reset method~:~reset method value~")을 포함한 ~secret~ 값을 전송합니다. 가장 일반적인 케이스로 이메일의 비밀번호 수정을 하는 코드는 아래와 같습니다.

	#+BEGIN_SRC
login: {
  id: "1a2b3",
  scheme: "reset",
  secret: base64encode("basic:email:jdoe@example.com")
}
	#+END_SRC

	여기서 ~jdoe@example.com~ 은 이전에 검증된 사용자의 이메일입니다.

	이메일이 등록된 데이터와 일치하면, 서버는 비밀번호를 재설정 하기 위한 지시 사항과 함께 지정된 방법 및 주소를 사용하여 메세지를 보냅니다. [[#Changing Authentication Parameters][Changing Authentication Parameters]] 섹션에 설명된대로 이메일에는 ~{acc}~ request에 포함할 수 있는 시크릿 코드가 포함되어 있습니다.

** Suspending a User
   사용자 계정은 관리자에 의해 정지될 수 있습니다. 계정이 정지되면 사용자는 더이상 로그인 할 수 없고 서비스도 이용할 수 없습니다.

   ~root~ 사용자만이 다른 계정을 정지시킬 수 있습니다. 관리자에 의해 계정이 정지된 사용자는 아래의 메세지를 받습니다.

   #+BEGIN_SRC
acc: {
  id: "1a2b3", // string, client-provided message id, optional
  user: "usr2il9suCbuko", // user being affected by the change
  status: "suspended"
}
   #+END_SRC

   정지가 해제된 계정은 위와 동일한 메세지를 수신하지만 ~status: "ok"~ 값이 담긴 메세지를 수신합니다. 관리자는 ~{get what="desc"}~ 커맨드를 실행하여 사용자의 ~me~ topic을 조회할 수 있습니다.

** Credential Validation
   서버는 필요하다면 특정 인증 체계를 이용한 사용자 계정 인증 기능을 선택적으로 구성할 수 있습니다. 예를 들어, 사용자에게 고유한 이메일, 전화번호 등을 제공하도록 요구하거나 계정 등록 조건으로 보안 문자를 해결하도록 요구할 수 있습니다.

   서버는 약간의 설정 변경만으로 이메일 인증을 지원할 수 있습니다. 대부분 잘 동작하며, 문자 메세지를 보내기 위해서는 별도 상용 서비스가 필요하기 때문에  전화번호 인증 기능은 제대로 동작하지 않습니다.

   자격 증명이 활성화 된 상태일 경우, 사용자는 항상 유효성 검사에 통과된 상태여야 합니다. 필수 자격 증명을 변경해야 하는 경우엔 사용자가 먼저 새 자격 증명을 추가하고 유효성 검사를 한 다음 이전 자격 증명을 제거해야 합니다.

   자격 증명은 ~{acc}~ 메세지를 보내 할당되고, ~{set topic="me"}~ 를 통해 추가되고, ~del topic="me"~ 를 통해서 삭제됩니다. 자격 증명은 ~{login}~ 또는 ~{acc}~ 메세지를 전송하여 클라이언트 측에서 확인됩니다.

** Access Control
   :PROPERTIES:
   :CUSTOM_ID: Access Control
   :END:
   Access Control은 Access Control 목록(ACLs) 또는 Bearer Token(bearer token은 0.15 버전부터는 구현되지 않음)을 통해 Topic에 대한 Access를 관리합니다.

   Access Control은 대부분 group topic에 사용됩니다. ~me~, P2P Topic에 대해서는 현재 상태 알림을 관리하고 1:1 대화를 시작하거나 대화를 중지하는 등 제한적인 용도로 사용됩니다.
   사용자의 Topic에 대한 Access는  권한을 요청하는 "want", 그리고 Topic에 대한 매니저 권한을 부여하는 "given" 등 두 가지로 나뉩니다. 각 권한은 bitmap에 bit 단위로 표현됩니다. 이는 존재하거나 없을 수 있습니다. 실제 Access는 원하는 권한(want)와 부여된 권한(given)의 bit값을 AND 연산한 결과로 결정됩니다. 연산 결과(즉, 권한)는 ASCCII 문자열 형태로 메세지로 전달됩니다. 다음 목록의 문자열은 설정된 권한 bit를 의미합니다.

   + No Access: ~N~, 권한이 명시적으로 설정되지 않았음을 의미합니다. 일반적으로 기본 권한이 적용되지 않아야 함을 나타냅니다.
   + Join: ~J~, Topic을 구독할 수 있는 권한을 나타냅니다.
   + Read: ~R~, ~{data}~ 패킷을 수신할 수 있는 권한을 나타냅니다.
   + Write: ~W~, ~{pub}~ 토픽에 대한 권한을 나타냅니다.
   + Presense: ~P~, ~{pres}~ 메세지를 수신하여 현재 상태를 갱신할 수 있는 권한을 나타냅니다.
   + Approve: ~A~, Topic 참여 요청을 승인할 수 있는 권한을 나타냅니다. 이 권한을 가진 사용자는 해당 Topic의 관리자입니다.
   + Sharing: ~S~, 다른 사용자를 Topic에 초대할 수 있는 권한을 나타냅니다.
   + Delete: ~D~, 메세지 영구 삭제 권한, 토픽의 소유자만 이 기능을 사용할 수 있습니다.
   + Owner: ~O~, 토픽의 소요자를 의미합니다. Topic 당 최대 한명의 소유자만 존재할 수 있습니다. 일부 Topic은 소유자가 없을 수 있습니다.
   
   Topic의 기본 액세스는 Topic 생성 시 ~{sub, desc, defacs}~ 에 의해 설정되며, 이후에 ~{set}~ 메세지를 이용해 수정할 수 있습니다. 기본 액세스는 인증 사용자와 익명 사용자 두 범주에 대해 정의됩니다. 이 값은 모든 새 참석자(subscription)에 대해 "given" 권한이 적용됩니다.

   클라이언트는 ~{sub}~, ~{set}~ 메세지의 권한을 빈 문자열로 대체하여 Tinode 기본 권한으로 초기화 할 수 있습니다. 클라이언트가 Topic을 생성할 때 기본 액세스 권한을 설정하지 않으면 인증된 사용자는 ~RWP~ 권한을 부여받게 되고 익명 사용자는 빈 권한을 부여받아 관리자에게 별도로 승인을 받아야만 Topic에 참여할 수 있습니다.

   액세스 권한은 ~{set}~ 메세지를 사용해 사용자별로 할당할 수 있습니다.

* Topics 
  Topic은 한명 또는 여러명이서 커뮤니케이션을 하는 채널을 의미합니다. 모든 토픽은 persistent property를 가지고 있습니다. 이러한 토픽의 property는 ~{get what="desc"}~ 메세지를 이용해서 쿼리를 요청할 수 있습니다.

  아래의 Topic property 목록은 쿼리를 호출하는 사용자가 누구든 독립적으로 존재합니다.

  + ~created~: Topic이 생성된 시간(timestap)
  + ~updated~: Topic의 ~public~ 또는 ~private~ 속성이 마지막으로 수정된 시간(timestamp)
  + ~touched~: Topic에 마지막으로 메세지가 전송된 시간(timestamp)
  + ~defacs~: 인증 사용자와 익명 사용자를 위한 액세스 모드를 나타내는 속성. 자세한 내용은 [[#Access Control][Access Control]]을 참고하세요
  + ~auth~: 인증 사용자를 위한 액세스 모드를 나타내는 속성
  + ~anon~: 익명 사용자를 위한 액세스 모드를 나타내는 속성
  + ~seq~: Topic에 전송된 최신 ~{data}~ 메세지의 고유 아이디. 서버측에서 생성한 integer 값.
  + ~public~: Topic을 설명하는 어플리케이션 정의 객체. Topic을 구독할 수 있는 사람은 누구나 Topic의 public data를 조회할 수 있습니다.

  사용자 종속 Topic 속성 목록

  + ~acs~: 현재 사용자의 해당 Topic에 대한 액세스 권한을 나타내는 속성. 자세한 내용은 [[#Access Control][Access Control]]을 참고하세요.
  + ~want~: 현재 사용자가 요청한 접근 권한
  + ~given~: 현재 사용자의 접근 권한
  + ~private~: 현재 사용자 고유의 어플리케이션 정의 객체.

  Topic은 보통 구독자가 있습니다. 구독자 중 한명은 전체 액세스 권한이 있는 Topic 소유자로 지정될 수 있습니다(~O~ 액세스 권한). 구독자 목록은 ~{get what="sub"}~ 메세지를 이용해서 조회할 수 있습니다. 구독자 목록은 ~{meta}~ 메세지의 ~sub~ 섹션 형태로 반환됩니다.

** ~me~ Topic
   ~me~ Topic은 모든 사용자가 각자 계정을 생성할 때 자동으로 생성됩니다. 이 Topic은 계정 정보를 관ㄹ리하고 관심있는 사람과 Topic으로부터 알림을 받는 용도로 사용됩니다. ~me~ Topic은 소유자가 없습니다. 이 Topic은 삭제하거나 구독 취소를 할 수 없습니다. 모든 관련 커뮤니케이션을 중단하고 사용자가 오프라인 상태임을 나타낼 수 있습니다(하지만 사용자는 여전히 로그인 되어있고 다른 Topic을 사용할 수 있습니다.).

   ~me~ Topic에 보낸 ~{get what = "desc"}~ 메세지는 ~{meta}~ 메세지가 포함된 ~desc~ 섹션이 topic 파라메터와 함께 자동으로 반환됩니다([[#Topic][Topic]] 섹션을 참고하세요). ~me~ topic의 ~public~ 파라메터는 사용자 연결에 표시하려는 데이터입니다. ~public~ 파라메터를 변경하면 ~me~ Topic뿐만 아니라 사용자의 ~public~ 정보가 표시된 모든 곳이 변경됩니다.

   다른 Topic에 ~{get what="sub"}~ 메세지를 보내면 해당 토픽의 구독자 목록을 반환하는것과 달리 ~me~ Topic에 보내는 ~{get what="sub"}~ 메세지는 현재 사용자가 구독한 Topic 목록을 반환합니다.

   + seq: 서버측에서 발급한 topic의 마지막 message 고유 ID값
   + recv: 현재 사용자가 수신받은 메세지에 대해 직접 설정한 seq 값
   + read: 현재 사용자가 읽은 메세지에 대해 직접 설정한 seq 값
   + seen: P2P Topic 구독의 경우, 사용자의 마지막 온라인 시간(timestamp) 및 User Agent 값
   + when: 사용자의 마지막 온라인 시간
   + ua: 사용자가 마지막으로 사용한 클라이언트 소프트웨어에 대한 user agent 값

   ~me~ Topic에 보내는 ~{get what="data"}~ 메세지는 거부됩니다.

** ~fnd~ and Tags: Finding Users and Topics
:PROPERTIES:
:CUSTOM_ID: fnd
:END:

   ~fnd~ Topic은 모든 사용자가 각자 계정을 생성할 때 자동으로 생성됩니다. 이 Topic은 다른 사용자나 group Topic을 검색할 때 사용됩니다. 사용자와 group topic은 ~tags~ 키워드를 기준으로 검색합니다. 태그는 Topic 또는 사용자 생성 시 지정할 수 있으며, 이 후에는 ~{set what="tags"}~ 를 사용하여 ~me~ 또는 group Topic의 tags를 수정할 수 있습니다.

   태그는 대소문자를 구분하지 않는 유니코드 문자열(서버에서 강제로 소문자로 적용)이며, 문자 및 숫자 유니코드 [[https://en.wikipedia.org/wiki/Unicode_character_property#General_Category][클래스/카테고리]] 문자뿐만 아니라 ASCII 문자(~_~, ~.~, ~+~, ~-~, ~@~, ~#~, ~!~, ~?~)를 포함할 수 있습니다.

   태그는 네임 스페이스 역할을 하는 접두사가 있을 수 있습니다. 이 접두사는 2-16개 사이의 string 문자열이며 [a-z] 로 시작하며, 소문자 ASCII 문자 및 숫자와 콜론을 포함할 수 있는데(~:~), 예를 들어 휴대전화 태그는 ~tel:+14155551212~ 처럼 나타내며 이메일 주소는 ~email:alice@example.com~ 처럼 나타냅니다. 일부 접두사 태그는 선택적으로 고유도록 적용됩니다(unique). 이 경우 한명의 사용자 또는 Topic만 이러한 태그를 가질 수 있습니다. 특정 태그는 사용자가 변경할 수 없도록 강제할 수 있습니다. 즉, 사용자가 변경 불가능한 태그를 추가하거나 제거하려는 시도는 서버에서 거부됩니다.

   태그는 서버측에서 인덱싱되며 사용자 및 Topic 검색에 사용됩니다. 검색은 일치하는 태그 수를 기준으로 내림차순으로 정렬됩니다.

   사용자 또는 Topic을 찾기 위해 사용하는 ~fnd~ Topic의 ~public~ 또는 ~private~ 파라메터 변수를 검색 쿼리([[#Query Language][Query language]] 참고)로 설정하고 ~{get topic="fnd" what="sub"}~ 메세지를 보냅니다. 만약 ~public~, ~private~ 둘 다 설정했다면, ~public~ 값이 사용됩니다. ~private~ 쿼리는 세션과 디바이스 기기에서 유지됩니다, 예를 들어 모든 유저 세션은 같은 ~private~ 쿼리를 조회하게 됩니다. ~public~ 쿼리의 장점은 휘발성, 즉, 데이터베이스에 저장되거나 사용자 세션끼리 공유되지 않습니다. ~private~ 쿼리는 휴대 전화의 사용자 접속 목록에 있는 모든 사람의 일치 항목을 찾는 것과 같은 자주 변경되지 않는 대규모 작업 쿼리를 위한 것입니다. ~public~ 쿼리는 특정 Topic 또는 내 휴대전화 목록에 없는 사용자를 찾는 것과 같과 같이 간단한 쿼리 작업에 주로 쓰입니다.

   시스템은 발견된 사용자 또는 Topic의 세부정보를 구독 형식으로 ~subsection~ section에 담아 ~{meta}~ message 형태로 반환합니다.

   ~fnd~ Topic은 읽기 전용으로, ~fnd~ Topic에 ~{pub}~ 메세지를 보낼 경우 거절당합니다.

   /현재 지원하지 않음/ 새 사용자가 지정된 쿼리와 일치하는 태그를 등록하면 ~fnd~ Topic이 새 사용자 등록을 알리는 ~{pres}~ 메세지를 반환합니다.

   [[https://github.com/tinode/chat/tree/master/pbx][Plugins]]을 이용해 커스텀 검색 기능을 제공할 수 있습니다.

*** Query Language
:PROPERTIES:
:CUSTOM_ID: Query Language
:END:
    Tinode query language는 사용자와 Topic을 검색하기 위한 언어입니다. 쿼리는 공백 또는 쉼표로 구분된 문자열입니다. 각 검색어는 사용가 또는 Topic의 태그들과 일치합니다. 각 검색어는 RTL 방식으로 쓰여졌을 수 있지미만 쿼리는 항상 왼쪽에서 오른쪽 방향으로 파싱됩니다. 공백은 ~AND~ 연산으로 처리되며, 쉼표(앞뒤에 공백이 있는 쉼표 포함)는 ~OR~ 연산으로 처리됩니다. 연산자의 순서는 무시됩니다. ~A~ND 연산자는 AND 연산자끼리, ~OR~ 연산자는 OR 연산자끼리 그룹화됩니다. ~OR~ 연산이 ~AND~ 보다 우선순위가 높습니다. 태그 앞에 쉼표가 오면 ~OR~ 태그, 그렇지 않으면 ~AND~ 로 취급됩니다. 예를 들어, ~aaa bbb, ccc~ (~aaa AND bbb OR ccc~)는 ~(bbb or CCC) AND aaa~ 로 해석됩니다.

	공백이 포함된 검색어는 공백을 언더바(_)로 치환해서 검색해야 합니다 ~‎~ -> ~_~ (예: ~new york~ -> ~new_york~).
**** Some examples:
	 + ~flowers~: ~flowers~ 태그가 있는 사용자 또는 Topic을 검색합니다.
	 + ~flowers travel~: ~flowers~, ~travel~ 두 태그를 모두 포함한 사용자 또는 Topic을 검색합니다.
	 + ~flowers, travel~: ~flowers~ 또는 ~travel~ 둘 중 하나의 태그라도 포함한 사용자 또는 Topic을 검색합니다(또는 둘 다 포함한).
	 + ~flowers travel, puppies~: ~flowers~ 를 포함하고 ~travel~ 또는 ~puppies~ 를 포함한 사용자 또는 Topic을 검색합니다(~(travel OR puppies) AND flowers~).
	 + ~flowers, travel puppies, kitten~: ~flowers~, ~travel~, ~puppies~, ~kittens~ 중 하나라도 포함한 사용자 또는 Topic을 검색합니다. ~travel~ 과 ~puppies~ 사이에 있는 공백은 ~OR~ 연산이 ~AND~ 연산보다 우선하므로 ~OR~ 로 치환됩니다.
	
*** Incremental Updates to Queries
	/현재 지원하지 않는/ 쿼리입니다. 특히 ~fnd.private~ 는 메세지 크기 제한과 기본 데이버테이스 쿼리 크기 제한에 의해서만 제한될 수 있습니다. 전체 쿼리를 다시 작성하여 검색어를 추가하거나 제거하는 대신, 검색어를 점진적으로 추가하거나 제거할 수 있습니다.

	incremental update 요청은 왼쪽에서 오른쪽으로 처리됩니다. 또한 동일한 검색어를 여러 번 포함할 수 있습니다. 즉, ~-a_tag+a_tag~ 는 유효한 요청입니다.

*** Query Rewrite
login, 전화번호 또는 이메일로 사용자를 찾으려면 ~alice@example.com~ 대신 ~email:alice@example.com~ 같이 접두사를 사용하여 검색어를 작성해야 합니다. 이러한 방법은 사용자가 직접 쿼리를 배워야 하기 때문에 문제가 될 수 있습니다. tinode는 이 문제를 서버에서 /쿼리를 재작성/ 하는 방식으로 문제를 해결했습니다. 만약 검색어가 접두사가 없을 경우, 서버가 적절한 접두사를 붙여 쿼리를 재작성 합니다. ~fnd.public~ 에 대한 쿼리에서 원래 용어도 유지되고(쿼리문 ~alice@example.com~ 은 ~email:alice@example.com OR alice@example~ 로 재작성 됩니다.) ~fnd.private~ 에 대한 쿼리에서는 다시 작성된 검색어만 유지됩니다(~alice@example.com~ 쿼리는 ~email:alice@example.com~ 으로 재작성 됩니다.). ~alice@example~ 처럼 이메일처럼 보이는 모든 검색어는 ~email:alice@example.com OR alice@example.com~ 처럼 재작성 됩니다. 전화번호처럼 보이는 용어는 [[https://en.wikipedia.org/wiki/E.164][E.164]] 형식으로 변환되고 ~tel:+14155551212 OR +14155551212~ 형식으로 재작성됩니다. 그리고 ~fnd.public~ 에 대한 쿼리에서 로그인처럼 보이는 접두사가 없는 모든 용어는 ~alice~ -> ~basic:alice OR alice~ 형식으로 재작성 됩니다.

위에서 설명한대로 전화번호처럼 보이는 태그는 E.164 형식으로 변환됩니다. 이러한 변환에는 ISO3166-1 alpha-2 국가코드가 필요합니다. 전화번호 태그를 E.164 형식으로 변환하는 로직은 아래와 같습니다.

  + 태그에 이미 국가 전화코드가 포함되어 있으면 그대로 사용합니다. ~+1(415)555-1212~ -> ~+14155551212~.
  + 만약 태그에 접두사가 없다면, ~{hi}~ 메세지를 통해 설정된 클라이언트의 ~lang~ 필드를 참고하여 국가코드를 설정합니다.
  + 만약 클라이언트 ~hi.lang~ 값을 통해 국가코드를 추출하지 못했다면, ~tinode.conf~ 파일에 설정된 ~default_country_code~ 필드값을 이용해 국가코드를 설정합니다.
  + ~tinode.conf~ 파일의 ~default_country_code~ 값이 없을 경우, ~us~ 국가코드를 기본값으로 사용합니다.

*** Possible Use Cases
+ 사용자를 조직으로 제한합니다. 변하지 않는 태그를 사용자에게 할당에 사용자가 어느 조직에 소속되어 있는지 표시할 수 있습니다. 사용자가 다른 사용자 또는 Topic을 검색할 때, 검색에 항상 태그를 포함해야 하도록 제한할 수 있습니다. 이 방식은 서로 다른 조직이 서로 검색되지 않도록 사용자를 세분화 하는 데 사용할 수 있습니다.
+ 위치 정보를 기반으로 검색할 수 있습니다. 클라이언트가 주기적으로 사용자의 위치를 기반으로 생성한 [[https://en.wikipedia.org/wiki/Geohash][geohash]] 태그를 등록할 수 있습니다. 특정 지역에서 사용자를 검색하면 geosh 태그가 해당 위치에 속한 사용자를 검색할 수 있습니다.
+ Search by numerical range, such as age range. The approach is similar to geohashing. The entire range of numbers is covered by the smallest possible power of 2, for instance the range of human ages is covered by 27=128 years. The entire range is split in two halves: the range 0-63 is denoted by 0, 64-127 by 1. The operation is repeated with each subrange, i.e. 0-31 is 00, 32-63 is 01, 0-15 is 000, 32-47 is 010. Once completed, the age 30 will belong to the following ranges: 0 (0-63), 00 (0-31), 001 (16-31), 0011 (24-31), 00111 (28-31), 001111 (30-31), 0011110 (30). A 30 y.o. user is assigned a few tags to indicate the age, i.e. ~age:00111~, ~age:001111~, and ~age:0011110~. Technically, all 7 tags may be assigned but usually it's impractical. To query for anyone in the age range 28-35 convert the range into a minimal number of tags: ~age:00111~ (28-31), ~age:01000~ (32-35). This query will match the 30 y.o. user by tag ~age:00111~.

** Peer to Peer Topics
Peer to Peer(P2P) Topic은 오직 단 두 사용자의 소통을 위한 채널입니다. 같은 하나의 Topic이라도 Topic의 이름은 각 사용자마다 다릅니다. 각 사용자들은 상대방의 ID(~usr~ 뒤에 붙는 사용자의 base64 URL-encoded ID)를 Topic의 이름으로 인식합니다. 예를 들어, 사용자 ~usrOj0B3-gSBSs~, ~usrIU_LOVwRNsc~ 둘이서 P2P Topic을 시작했다면, ~usrOj0B3-gSBSs~ 사용자는 Topic의 이름을 ~usrIU_LOVwRNsc~ 로 인식합니다. 반대로 ~usrIU_LOVwRNsc~ 사용자는 Topic의 이름을 ~usrOj0B3-gSBSs~ 로 인식합니다.

P2P Topic은 사용자가 다른 사용자의 ID를 이름의 topic을 구독하면 생성됩니다. 만약 ~usrOj0B3-gSBSs~ 사용자가 ~{sub topic="usrIU_LOVwRNsc"}~ 메세지를 보낸다면 ~usrIU_LOVwRNsc~ 사용자를 대상으로 P2P Topic을 생성할 수 있습니다. Tinode는 위에서 설명한대로 ~{ctrl}~ 패킷과 함께 새로 생성된 Topic의 이름을 반환합니다. 상대 사용자는 액세스 권한이 있는 ~me~ topic을 통해 ~{pres}~ 메세지를 수신합니다.

P2P topic의 'public' 파라메터는 사용자에 따라 다릅니다. 예를 들어 사용자 A와 B 사이의 P2P topic은 사용자 A의 'public' 정보를 B에게 표시하고 반대의 경우도 마찬가지입니다. 사용자가 'public' 정보를 수정하면, 모든 사용자의 P2P topic에 자동으로 'public' 정보가 변경됩니다.

P2P topic의 'private' 파라메터는 다른 topic 타입과 마찬가지로 각 사용자가 각각 개별적으로 정의합니다.

** Group Topics
** ~sys~ Topic
* Using Server-Issued Message IDs
* User Agent and Presence Notifications
* Public and Private Fields 
** Public
** Private
* Format of Content
* Out-of-Band Handling of Large Files 
:PROPERTIES:
:CUSTOM_ID: Out-of-Band Handling of Large Files 
:END:
** Uploading
** Downloading
* Push Notifications 
** Tinode Push Gateway
** Google FCM
** Stdout
* Messagse
** Client to Server Messages 
*** ~{hi}~
*** ~{acc}~
:PROPERTIES:
:CUSTOM_ID: acc
:END:
*** ~{login}~
:PROPERTIES:
:CUSTOM_ID: login
:END:
*** ~{sub}~
:PROPERTIES:
:CUSTOM_ID: sub
:END:
*** ~{leave}~
*** ~{pub}~
*** ~{get}~
*** ~{set}~
*** ~{del}~
*** ~{note}~
** Server to Client Messages 
*** ~{data}~
*** ~{ctrl}~
*** ~{meta}~
*** ~{pres}~
*** ~{info}~
